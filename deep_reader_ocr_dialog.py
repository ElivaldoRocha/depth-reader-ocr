# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DepthReaderOCRDialog
                                 A QGIS plugin
 Automatically extracts depth values from nautical charts using OCR.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-06-21
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Elivaldo Rocha
        email                : carvalhovaldo09@gmail.com
 ***************************************************************************/

/***************************************************************************
 * *
 * This program is free software; you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation; either version 2 of the License, or     *
 * (at your option) any later version.                                   *
 * *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QFileDialog, QCheckBox, QVBoxLayout
from qgis.PyQt.QtCore import Qt

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'deep_reader_ocr_dialog_base.ui'))


class DepthReaderOCRDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(DepthReaderOCRDialog, self).__init__(parent)
        self.setupUi(self)

        
        # Adiciona o checkbox de modo de opera√ß√£o
        self.setup_ocr_checkbox()

        # Conectar bot√µes de procurar
        if hasattr(self, 'btnBrowseDebugDir'):
            self.btnBrowseDebugDir.clicked.connect(self.browse_debug_directory)
        if hasattr(self, 'btnBrowseCSV'):
            self.btnBrowseCSV.clicked.connect(self.browse_csv_file)

        # Configurar informa√ß√µes e valores padr√£o
        self._set_default_values()
        
        # For√ßa a atualiza√ß√£o da visibilidade da aba 'Avan√ßado' no in√≠cio
        self.on_ocr_mode_changed(self.chkUseOCR.isChecked())
        
        # Define a aba "Geral" como a aba inicial padr√£o
        self.tabWidget.setCurrentIndex(1)

    def _set_default_values(self):
        """Configura os valores padr√£o para todos os campos da UI."""
        default_user_dir = os.path.expanduser("~")

        # Aba Geral
        if hasattr(self, 'leCSVPath'):
            self.leCSVPath.setText(os.path.join(default_user_dir, "batimetria.csv"))

        # Aba Avan√ßado
        if hasattr(self, 'leDebugDir'):
            self.leDebugDir.setText(os.path.join(default_user_dir, "depth_reader_debug"))
        if hasattr(self, 'cbClipSize'):
            self.cbClipSize.clear()
            self.cbClipSize.addItems(["16", "32", "48", "64", "80", "96"])
            self.cbClipSize.setCurrentText("96")
            self.cbClipSize.setEnabled(True)
        
        # Define os valores padr√£o para os novos campos de configura√ß√£o do OCR
        if hasattr(self, 'leRotations'):
            self.leRotations.setText("-90, -45, 0, 45, 90, 180, 270")
        if hasattr(self, 'chkClahe'):
            self.chkClahe.setChecked(True)
        if hasattr(self, 'chkGaussian'):
            self.chkGaussian.setChecked(True)
        if hasattr(self, 'chkMean'):
            self.chkMean.setChecked(True)
        
        # Aba Sobre
        if hasattr(self, 'tbInfo'):
            self.tbInfo.setText(self.get_info_text())
            self.tbInfo.setOpenExternalLinks(True)

    def setup_ocr_checkbox(self):
        """
        Adiciona o checkbox de OCR √† interface de forma robusta.
        Procura por um layout chamado 'ocr_checkbox_placeholder_layout' no arquivo .ui.
        """
        try:
            # Cria o checkbox
            self.chkUseOCR = QCheckBox("ü§ñ Usar vis√£o computacional (OCR)")
            self.chkUseOCR.setChecked(True)  # Marcado por padr√£o
            self.chkUseOCR.setToolTip(
                "‚úÖ Marcado: Usa OCR autom√°tico para detectar profundidades\n"
                "‚ùå Desmarcado: Permite entrada manual de valores"
            )
            
            # Conecta o sinal 'toggled' para atualizar a interface
            self.chkUseOCR.toggled.connect(self.on_ocr_mode_changed)
            
            # Tenta encontrar o layout placeholder (M√©todo 1)
            placeholder_layout = self.findChild(QVBoxLayout, "ocr_checkbox_placeholder_layout")
            
            if placeholder_layout:
                # Se encontrou o layout, adiciona o checkbox a ele. Esta √© a forma ideal.
                placeholder_layout.addWidget(self.chkUseOCR)
                print("‚úÖ Checkbox OCR adicionado ao layout de placeholder.")
            else:
                # --- IN√çCIO DA CORRE√á√ÉO (M√âTODO 2) ---
                # Se n√£o encontrou o placeholder, usa o Plano B corrigido.
                print("‚ö†Ô∏è  Aviso: Layout 'ocr_checkbox_placeholder_layout' n√£o foi encontrado.")
                print("   Usando o M√©todo 2 para posicionar o checkbox na aba 'Geral'.")
                
                geral_tab_widget = None
                # Procura a aba pelo nome "Geral" para ser mais robusto
                if hasattr(self, 'tabWidget'):
                    for i in range(self.tabWidget.count()):
                        if self.tabWidget.tabText(i) == "Geral":
                            geral_tab_widget = self.tabWidget.widget(i)
                            break

                if geral_tab_widget:
                    # Verifica se a aba "Geral" j√° tem um layout. Se n√£o, cria um.
                    if not geral_tab_widget.layout():
                        print("   Criando um novo layout vertical para a aba 'Geral'.")
                        new_layout = QVBoxLayout()
                        geral_tab_widget.setLayout(new_layout)
                    
                    # Adiciona o checkbox ao layout da aba "Geral"
                    geral_tab_widget.layout().insertWidget(0, self.chkUseOCR) # Insere no topo
                    print("‚úÖ Checkbox OCR adicionado com sucesso √† aba 'Geral'.")
                else:
                    print("‚ùå ERRO CR√çTICO: N√£o foi poss√≠vel encontrar a aba 'Geral'.")
                # --- FIM DA CORRE√á√ÉO ---

        except Exception as e:
            print(f"‚ö†Ô∏è Erro cr√≠tico ao criar checkbox OCR: {e}")
            # Cria um atributo vazio para evitar que o resto do plugin falhe
            self.chkUseOCR = QCheckBox()
            self.chkUseOCR.setVisible(False)
            self.chkUseOCR.setParent(self)

    def on_ocr_mode_changed(self, checked):
        """Callback chamado quando o modo OCR √© alterado."""
        # Habilita/desabilita a aba "Avan√ßado" inteira
        try:
            # O √≠ndice 1 corresponde √† segunda aba ("Avan√ßado") na ordem Sobre, Geral, Avan√ßado.
            # Uma forma mais robusta seria procurar pelo nome, mas o √≠ndice funciona.
            # Assumindo a ordem: 0=Sobre, 1=Geral, 2=Avan√ßado
            advanced_tab_index = -1
            if hasattr(self, 'tabWidget'):
                for i in range(self.tabWidget.count()):
                    if self.tabWidget.tabText(i) == "Avan√ßado":
                        advanced_tab_index = i
                        break

            if advanced_tab_index != -1:
                self.tabWidget.setTabEnabled(advanced_tab_index, checked)
                if checked:
                    print("‚úÖ Modo OCR ativado. Aba de configura√ß√µes avan√ßadas habilitada.")
                else:
                    print("‚úã Modo manual ativado. Aba de configura√ß√µes avan√ßadas desabilitada.")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao alterar visibilidade da aba: {e}")

    def get_info_text(self):
        """Retorna o texto de informa√ß√µes da caixa de di√°logo."""
        return (
            "<h3>Depth Reader OCR</h3>"
            "Este plugin permite extrair manual e automaticamente valores de profundidade de cartas n√°uticas raster (GeoTIFF) da Marinha do Brasil usando OCR.<br><br>"
            
            "<b>MODOS DE OPERA√á√ÉO:</b><br>"
            "<ul><li><b>Vis√£o Computacional (OCR):</b> Detecta automaticamente as profundidades.</li>"
            "<li><b>Entrada Manual:</b> Permite que voc√™ digite os valores manualmente.</li></ul>"
            
            "<b>Onde Baixar Cartas N√°uticas Raster?</b><br>"
            "Voc√™ pode baixar as Cartas Raster (GeoTIFF) gratuitamente no site oficial da Marinha do Brasil:<br>"
            "<a href='https://www.marinha.mil.br/chm/dados-do-segnav/cartas-raster'>www.marinha.mil.br/chm</a><br><br>"
            
            "<b>Requisitos do Sistema - Tesseract OCR:</b><br>"
            "Para funcionamento ideal, √© necess√°rio instalar o Tesseract OCR em seu sistema:<br>"
            "&bull; <a href='https://github.com/UB-Mannheim/tesseract/wiki'>Download Tesseract OCR (Windows)</a><br>"
            "&bull; <a href='https://tesseract-ocr.github.io/tessdoc/Installation.html'>Download Tesseract OCR (Linux/Mac)</a><br>"
            "<br><br>"
            "‚ö†Ô∏è <b>IMPORTANTE:</b> Na instala√ß√£o, marque a op√ß√£o 'Add Tesseract to PATH'. Se n√£o aparecer a op√ß√£o, voc√™ pode adicion√°-la manualmente nas vari√°veis de ambiente do sistema."
            "<br><br>"
            "<br>üìñ <b>Mais Informa√ß√µes:</b><br>"
            "Para detalhes sobre o uso avan√ßado, instala√ß√µes de depend√™ncias, solu√ß√£o de problemas e contribui√ß√µes, consulte o "
            "<a href='https://github.com/elivaldorocha/depth-reader-ocr'>README no GitHub</a>.<br><br>"
        )

    def browse_debug_directory(self):
        directory = QFileDialog.getExistingDirectory(self, "Selecionar Diret√≥rio para Imagens de Debug", self.leDebugDir.text())
        if directory:
            self.leDebugDir.setText(directory)

    def browse_csv_file(self):
        file_path, _ = QFileDialog.getSaveFileName(self, "Salvar Arquivo CSV da Batimetria", self.leCSVPath.text(), "Arquivos CSV (*.csv)")
        if file_path:
            self.leCSVPath.setText(file_path)

    def get_debug_directory(self):
        return self.leDebugDir.text()

    def get_csv_path(self):
        return self.leCSVPath.text()

    def get_clip_size(self):
        try:
            return int(self.cbClipSize.currentText())
        except (AttributeError, ValueError):
            return 96 # Valor padr√£o seguro

    def get_use_ocr_mode(self):
        try:
            return self.chkUseOCR.isChecked()
        except AttributeError:
            return True

    def get_rotations(self):
        """L√™ a string de rota√ß√µes, limpa e converte para uma lista de inteiros."""
        try:
            raw_text = self.leRotations.text()
            rotations = [int(angle.strip()) for angle in raw_text.split(',') if angle.strip()]
            return rotations
        except (ValueError, AttributeError) as e:
            print(f"‚ö†Ô∏è Erro ao ler √¢ngulos de rota√ß√£o: {e}. Usando valores padr√£o.")
            return [-90, -45, 0, 45, 90]

    def get_preprocess_methods_config(self):
        """Verifica quais checkboxes de filtros est√£o marcados e retorna um dicion√°rio de configura√ß√£o."""
        try:
            config = {
                "clahe": self.chkClahe.isChecked(),
                "gaussian": self.chkGaussian.isChecked(),
                "mean": self.chkMean.isChecked()
            }
            return config
        except AttributeError as e:
            print(f"‚ö†Ô∏è Erro ao ler configura√ß√£o de filtros: {e}. Usando valores padr√£o.")
            return {"clahe": True, "gaussian": True, "mean": True}